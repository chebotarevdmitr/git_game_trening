Таким образом, следующая команда:

           $ git log foo bar ^baz

       означает "перечислить все коммиты, которые доступны из foo или bar, но не из
       baz".

       Специальное обозначение "<фиксация 1>..<фиксация 2>" может использоваться как сокращение для обозначения
       "^<фиксация 1> <фиксация 2>". Например, может использоваться любое из следующих значений
       взаимозаменяемо:

            источник $ git log..HEADКоманда использует параметры, применимые к команде git-rev-list(1), для
управления тем, что и как отображается, и параметры, применимые к команде git-diff(1)
       для управления тем, как отображаются изменения, вносимые каждой фиксацией.

опции
       --follow
       -- следуйте за мной
           Продолжить просмотр истории файла после переименования (работает только для
           одним файлом).
           
       --no-decorate, --decorate[=short|full|auto|no]
       --нет-украшать, --украшать[=короткое|полное|автоматическое|нет]
           Распечатайте имена ссылок для всех отображаемых коммитов. Если
указано значение short, то в имени ссылки используются префиксы refs/heads/, refs/tags/ и
           ссылки/remotes/ печататься не будут. Если указано значение full
, то будет напечатано полное имя ссылки (включая префикс). Если указано значение auto, то
, если выходные данные поступают на терминал, имена ссылок отображаются как короткие
           были заданы, в противном случае имена ссылок не отображаются. Параметр --decorate
           сокращенный вариант для --decorate=short. По умолчанию используется значение конфигурации
log.decorate, если оно настроено, в противном случае - автоматически.
           $ git log HEAD ^origin

       Еще одно специальное обозначение - "<фиксация 1>...<фиксация 2>", которое полезно для
       слияний. Результирующий набор фиксаций представляет собой симметричную разницу между
       два операнда. Следующие две команды эквивалентны:

           $ git log A B -не $(git merge-base -all A B)
           $ git log A...B

